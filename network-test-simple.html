<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Background Test</title>
    
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/loading.css">
    
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            overflow: hidden;
        }
        
        #bg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        
        .test-content {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: #00f3ff;
            font-family: 'Orbitron', monospace;
            text-align: center;
        }
        
        .test-info {
            background: rgba(10, 14, 39, 0.8);
            padding: 30px;
            border: 2px solid rgba(0, 243, 255, 0.3);
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .controls {
            margin-top: 20px;
        }
        
        .btn {
            background: linear-gradient(135deg, #00f3ff, #8b5cf6);
            border: none;
            color: white;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        
        .btn:hover {
            transform: scale(1.05);
        }
    </style>
</head>

<body>
    <!-- Network Background Canvas -->
    <canvas id="bg-canvas"></canvas>

    <!-- Test Content -->
    <div class="test-content">
        <div class="test-info">
            <h1>üåê Network Background Test</h1>
            <p>Testing the animated network lines for loading screen</p>
            <div class="controls">
                <button class="btn" onclick="startNetwork()">Start Network</button>
                <button class="btn" onclick="stopNetwork()">Stop Network</button>
                <button class="btn" onclick="restartNetwork()">Restart Network</button>
            </div>
            <div id="status" style="margin-top: 15px; color: #8b5cf6;">
                Status: Ready to test
            </div>
        </div>
    </div>

    <script>
        // Simple Network Background for Loading Screen
        class SimpleNetworkBackground {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) {
                    console.error(`Canvas not found: ${canvasId}`);
                    return;
                }

                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.connections = [];
                this.animationId = null;
                this.isRunning = false;
                
                this.config = {
                    nodeCount: 25,
                    maxConnections: 3,
                    connectionDistance: 250,
                    nodeSpeed: 0.1,
                    nodeSize: 1.5,
                    colors: {
                        primary: 'rgba(0, 243, 255, 0.6)',
                        secondary: 'rgba(139, 92, 246, 0.4)',
                        accent: 'rgba(255, 0, 110, 0.3)'
                    }
                };
                
                this.resize();
                this.createNodes();
                this.createConnections();
                
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.createNodes();
                this.createConnections();
            }

            createNodes() {
                this.nodes = [];
                
                for (let i = 0; i < this.config.nodeCount; i++) {
                    this.nodes.push({
                        id: i,
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * this.config.nodeSpeed,
                        vy: (Math.random() - 0.5) * this.config.nodeSpeed,
                        size: this.config.nodeSize + Math.random() * 1,
                        opacity: 0.4 + Math.random() * 0.4,
                        pulsePhase: Math.random() * Math.PI * 2
                    });
                }
            }

            createConnections() {
                this.connections = [];
                
                for (let i = 0; i < this.nodes.length; i++) {
                    const node1 = this.nodes[i];
                    let connectionCount = 0;
                    
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        if (connectionCount >= this.config.maxConnections) break;
                        
                        const node2 = this.nodes[j];
                        const distance = this.getDistance(node1, node2);
                        
                        if (distance < this.config.connectionDistance) {
                            this.connections.push({
                                node1: i,
                                node2: j,
                                strength: 1 - (distance / this.config.connectionDistance),
                                pulseOffset: Math.random() * Math.PI * 2
                            });
                            connectionCount++;
                        }
                    }
                }
            }

            getDistance(node1, node2) {
                const dx = node1.x - node2.x;
                const dy = node1.y - node2.y;
                return Math.sqrt(dx * dx + dy * dy);
            }

            updateNodes() {
                this.nodes.forEach(node => {
                    node.x += node.vx;
                    node.y += node.vy;

                    if (node.x < 0 || node.x > this.canvas.width) {
                        node.vx *= -1;
                        node.x = Math.max(0, Math.min(this.canvas.width, node.x));
                    }
                    if (node.y < 0 || node.y > this.canvas.height) {
                        node.vy *= -1;
                        node.y = Math.max(0, Math.min(this.canvas.height, node.y));
                    }

                    node.pulsePhase += 0.015;
                });

                if (Math.random() < 0.008) {
                    this.createConnections();
                }
            }

            draw() {
                this.ctx.fillStyle = 'rgba(10, 14, 39, 0.03)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.drawConnections();
                this.drawNodes();
            }

            drawConnections() {
                this.connections.forEach(connection => {
                    const node1 = this.nodes[connection.node1];
                    const node2 = this.nodes[connection.node2];
                    
                    if (!node1 || !node2) return;

                    const currentDistance = this.getDistance(node1, node2);
                    if (currentDistance > this.config.connectionDistance) return;

                    const opacity = connection.strength * 0.4;
                    const pulse = Math.sin(Date.now() * 0.0008 + connection.pulseOffset) * 0.3 + 0.7;

                    const gradient = this.ctx.createLinearGradient(
                        node1.x, node1.y, node2.x, node2.y
                    );
                    
                    gradient.addColorStop(0, `rgba(0, 243, 255, ${opacity * pulse})`);
                    gradient.addColorStop(0.5, `rgba(139, 92, 246, ${opacity * pulse * 0.7})`);
                    gradient.addColorStop(1, `rgba(255, 0, 110, ${opacity * pulse * 0.5})`);

                    this.ctx.strokeStyle = gradient;
                    this.ctx.lineWidth = 0.8 + connection.strength * 0.5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(node1.x, node1.y);
                    this.ctx.lineTo(node2.x, node2.y);
                    this.ctx.stroke();
                });
            }

            drawNodes() {
                this.nodes.forEach(node => {
                    const pulse = Math.sin(node.pulsePhase) * 0.3 + 0.7;
                    const currentSize = node.size * pulse;
                    const currentOpacity = node.opacity * pulse;

                    this.ctx.fillStyle = `rgba(0, 243, 255, ${currentOpacity})`;
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, currentSize, 0, Math.PI * 2);
                    this.ctx.fill();

                    const glowSize = currentSize * 3;
                    const gradient = this.ctx.createRadialGradient(
                        node.x, node.y, 0,
                        node.x, node.y, glowSize
                    );
                    
                    gradient.addColorStop(0, `rgba(0, 243, 255, ${currentOpacity * 0.6})`);
                    gradient.addColorStop(0.5, `rgba(139, 92, 246, ${currentOpacity * 0.3})`);
                    gradient.addColorStop(1, 'rgba(0, 243, 255, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, glowSize, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            animate() {
                if (!this.isRunning) return;

                this.updateNodes();
                this.draw();

                this.animationId = requestAnimationFrame(() => this.animate());
            }

            start() {
                if (this.isRunning) return;
                
                this.isRunning = true;
                this.animate();
                console.log('üåê Network background started');
                updateStatus('Network animation running');
            }

            stop() {
                this.isRunning = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                console.log('üåê Network background stopped');
                updateStatus('Network animation stopped');
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }
        }

        let networkBackground = null;

        function updateStatus(message) {
            document.getElementById('status').textContent = `Status: ${message}`;
        }

        function startNetwork() {
            if (!networkBackground) {
                networkBackground = new SimpleNetworkBackground('bg-canvas');
            }
            networkBackground.start();
        }

        function stopNetwork() {
            if (networkBackground) {
                networkBackground.stop();
            }
        }

        function restartNetwork() {
            if (networkBackground) {
                networkBackground.stop();
                networkBackground.clear();
            }
            networkBackground = new SimpleNetworkBackground('bg-canvas');
            networkBackground.start();
        }

        // Auto-start when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üéÆ Starting network background test...');
            updateStatus('Initializing...');
            
            setTimeout(() => {
                startNetwork();
            }, 500);
        });

        // Make globally available
        window.networkBackground = networkBackground;
        window.startNetwork = startNetwork;
        window.stopNetwork = stopNetwork;
        window.restartNetwork = restartNetwork;
    </script>
</body>
</html>